const fs=require("fs"),path=require("path"),util=require("util"),child_process=require("child_process"),{BACKUP_DIR:BACKUP_DIR="backups",BACKUP_FILES:BACKUP_FILES=["banned-ips.json","banned-players.json","config","dynmap","journeymap","mods","ops.json","server-icon.png","server.properties","whitelist.json","world"],BACKUP_FILENAME_PREFIX:BACKUP_FILENAME_PREFIX="backup-mcserver-",LOCAL_BACKUP_MAX_NUM:LOCAL_BACKUP_MAX_NUM=2,ALIST_ADDRESS:ALIST_ADDRESS,ALIST_USERNAME:ALIST_USERNAME,ALIST_PASSWORD:ALIST_PASSWORD,ALIST_BACKUP_DIR:ALIST_BACKUP_DIR,ALIST_BACKUP_MAX_NUM:ALIST_BACKUP_MAX_NUM=7,MAX_RETRY_TIMES:MAX_RETRY_TIMES=2,SEND_MESSAGE_API:SEND_MESSAGE_API,SEND_MESSAGE_AUTH:SEND_MESSAGE_AUTH,SEND_MESSAGE_CHAT_ID:SEND_MESSAGE_CHAT_ID,SERVER_HOST:SERVER_HOST}=require("./backup-mc-server.env"),IS_ALIST_ENABLED=!!(ALIST_ADDRESS&&ALIST_BACKUP_DIR&&ALIST_USERNAME&&ALIST_PASSWORD),IS_SEND_MESSAGE_ENABLED=!!SEND_MESSAGE_API,SEND_MESSAGE_TITLE=`<b>Minecraft backup${SERVER_HOST?`: ${SERVER_HOST}`:""}</b>\n\n`,cwd=process.cwd(),exec=util.promisify(child_process.exec),sleep=e=>new Promise((t=>{setTimeout((()=>{t()}),e)})),execFunctionWithRetry=async(e,{maxRetryTimes:t=MAX_RETRY_TIMES,functionLabel:a="execute function"})=>{let s=0;for(;s<=t;)try{console.info(`Try to ${a}...`),await e(),console.info(`${a} successfully!`);break}catch(e){console.error(`${a} failed:\n${e}`),s+=1}if(s>t)throw new Error(`${a} failed: retry too many times`)},sendMessageToChat=async e=>{if(!IS_SEND_MESSAGE_ENABLED)return;const t=new Headers;t.append("Authorization",SEND_MESSAGE_AUTH),t.append("Content-Type","application/json");try{const a=await fetch(SEND_MESSAGE_API,{method:"POST",headers:t,body:JSON.stringify({content:SEND_MESSAGE_TITLE+e,chatId:SEND_MESSAGE_CHAT_ID}),redirect:"follow"}),s=await a.text();if(200!==a.status)throw new Error(s);console.log(`Send message to chat successfully: ${s}`)}catch(e){console.log(`Send message to chat failed: ${e}`)}};let IS_BACKUP_FILE_CREATED=!1,IS_OLD_BACKUP_FILES_REMOVED=!1,IS_BACKUP_FILE_UPLOAD_ALIST=!1,IS_OLD_BACKUP_FILES_REMOVED_ALIST=!1;const isMCServerDir=()=>!!fs.existsSync(path.resolve(cwd,"eula.txt")),checkupDir=e=>{if(!fs.existsSync(e))try{fs.mkdirSync(e,{recursive:!0}),console.log(`Create dir \`${e}\` successfully.`)}catch(t){throw new Error(`Create dir \`${e}\` failed:\n`+t)}},genFilename=({baseDir:e,prefix:t})=>{const a=e=>String(e).padStart(2,"0"),s=new Date,o=s.getFullYear(),i=a(s.getMonth()+1),r=a(s.getDate()),n=a(s.getHours()),c=a(s.getMinutes()),l=a(s.getSeconds());return path.resolve(e,`${t}${o}-${i}-${r}-${n}-${c}-${l}.tar.gz`)},genBackup=async({filename:e,backupFiles:t=[]})=>{const a=t.filter((e=>!!fs.existsSync(path.resolve(cwd,e))));try{console.log(`Creating backup file \`${e}\` ...`),await exec(`tar -czf ${e} ${a.join(" ")}`),console.log(`Create backup file \`${e}\` successfully.`)}catch(t){throw new Error(`Create backup file \`${e}\` failed:\n`+t)}},getFileList=e=>fs.readdirSync(e).map((t=>{const a=fs.statSync(path.resolve(e,t));return a.name=t,a})),removeOldBackupFiles=({dir:e,prefix:t,maxNum:a})=>{const s=getFileList(e).filter((e=>e.isFile()&&e.name.startsWith(t))).sort(((e,t)=>t.mtimeMs-e.mtimeMs)).slice(a);if(!s.length)return;const o=s.map((e=>e.name));try{o.forEach((t=>{fs.rmSync(path.resolve(e,t))})),console.log(`Remove old backup files in \`${e}\` successfully: ${o.map((e=>`\`${e}\``)).join(", ")}.`)}catch(t){throw new Error(`Remove old backup files in \`${e}\` failed:\n`+t)}},printExecutionRes=()=>{console.log("\n=================================="),console.log(`Backup file is generated: ${IS_BACKUP_FILE_CREATED}\nOld backup files are removed: ${IS_OLD_BACKUP_FILES_REMOVED}`),IS_ALIST_ENABLED&&console.log(`Task that upload backup file to alist is started: ${IS_BACKUP_FILE_UPLOAD_ALIST}\nOld backup files in alist are removed: ${IS_OLD_BACKUP_FILES_REMOVED_ALIST}`),console.log("==================================\n")},getAlistToken=async({address:e,username:t,password:a})=>{const s=new Headers;s.append("Content-Type","application/json");const o={method:"POST",headers:s,body:JSON.stringify({username:t,password:a}),redirect:"follow"};try{const t=await fetch(`${e}/api/auth/login`,o),a=await t.text();if(200!==t.status)throw new Error(a);const s=JSON.parse(a);return console.log("Log in alist successfully."),s.data.token}catch(e){throw new Error("Log in alist failed:\n"+e)}},updateFileToAlist=async({address:e,token:t,dir:a,filePath:s,asTask:o})=>{const i=fs.statSync(s),r=path.basename(s),n=path.resolve(a,r),c=new Headers;c.append("Authorization",t),c.append("As-Task",o?"true":"false"),c.append("Content-Length",`${i.size}`),c.append("File-Path",encodeURIComponent(n));const l={method:"PUT",headers:c,body:fs.createReadStream(s),redirect:"follow",duplex:"half"};try{const t=await fetch(`${e}/api/fs/put`,l),a=await t.text();if(200!==t.status)throw new Error(a);console.log(`Start upload task successfully: local file \`${s}\` ==> alist \`${n}\`.`)}catch(e){throw new Error(`Upload file to alist \`${a}\` failed:\n`+e)}},getAlistFileList=async({address:e,token:t,dir:a})=>{const s=new Headers;s.append("Authorization",t),s.append("Content-Type","application/json");const o={method:"POST",headers:s,body:JSON.stringify({path:a,refresh:!0}),redirect:"follow"};try{const t=await fetch(`${e}/api/fs/list`,o),a=await t.text();if(200!==t.status)throw new Error(a);return JSON.parse(a).data.content||[]}catch(e){throw new Error(`Get file list in alist \`${a}\` failed:\n`+e)}},removeAlistOldBackupFiles=async({address:e,token:t,dir:a,prefix:s,maxNum:o})=>{const i=(await getAlistFileList({address:e,token:t,dir:a})).filter((e=>!e.is_dir&&e.name.startsWith(s))).sort(((e,t)=>e.modified>t.modified?-1:e.modified<t.modified?1:0)).slice(o);if(!i.length)return;const r=i.map((e=>e.name)),n=new Headers;n.append("Authorization",t),n.append("Content-Type","application/json");const c={method:"POST",headers:n,body:JSON.stringify({names:r,dir:a}),redirect:"follow"};try{const t=await fetch(`${e}/api/fs/remove`,c),s=await t.text();if(200!==t.status)throw new Error(s);console.log(`Remove old backup files in alist \`${a}\` successfully: ${r.map((e=>`\`${e}\``)).join(", ")}.`)}catch(e){throw new Error(`Remove old backup files in alist \`${a}\` failed:\n`+e)}},backupMCServer=async()=>{if(!isMCServerDir())throw new Error("You should execute this script at root dir of MineCraft server where `eula.txt` exists.");const e=path.resolve(cwd,BACKUP_DIR);checkupDir(e);const t=genFilename({baseDir:e,prefix:BACKUP_FILENAME_PREFIX});return await genBackup({filename:t,backupFiles:BACKUP_FILES}),t},removeLocalMCBackups=()=>{const e=path.resolve(cwd,BACKUP_DIR);removeOldBackupFiles({dir:e,prefix:BACKUP_FILENAME_PREFIX,maxNum:LOCAL_BACKUP_MAX_NUM})},uploadMCBackup=async e=>{if(IS_ALIST_ENABLED){const t=await getAlistToken({address:ALIST_ADDRESS,username:ALIST_USERNAME,password:ALIST_PASSWORD});await updateFileToAlist({address:ALIST_ADDRESS,token:t,dir:ALIST_BACKUP_DIR,filePath:e})}},removeRemoteMCBackups=async()=>{if(IS_ALIST_ENABLED){const e=await getAlistToken({address:ALIST_ADDRESS,username:ALIST_USERNAME,password:ALIST_PASSWORD});await removeAlistOldBackupFiles({address:ALIST_ADDRESS,token:e,dir:ALIST_BACKUP_DIR,prefix:BACKUP_FILENAME_PREFIX,maxNum:ALIST_BACKUP_MAX_NUM})}};(async()=>{let e;try{e=await backupMCServer(),IS_BACKUP_FILE_CREATED=!0,removeLocalMCBackups(),IS_OLD_BACKUP_FILES_REMOVED=!0}catch(e){console.error(`Resolve backup files in local failed: ${e}`),await sendMessageToChat(`Resolve backup files in local failed: ${e}`)}if(IS_ALIST_ENABLED&&e)try{await execFunctionWithRetry((async()=>{await uploadMCBackup(e),IS_BACKUP_FILE_UPLOAD_ALIST=!0,await sendMessageToChat(`Upload backup file <code>${e}</code> to AList successfully!`)}),{functionLabel:`upload \`${e}\` to AList`}),await execFunctionWithRetry((async()=>{await removeRemoteMCBackups(),IS_OLD_BACKUP_FILES_REMOVED_ALIST=!0}),{functionLabel:"remove old backups in AList"})}catch(e){console.error(`Resolve backup files in AList failed: ${e}`),await sendMessageToChat(`Resolve backup files in AList failed: ${e}`)}printExecutionRes()})();